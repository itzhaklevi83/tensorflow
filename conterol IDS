""" create and control IDS"""
class DNSIDS(DNSNeuronModel):
    group_flag = True
    def __init__(self, g_C=0.5*c_mScaled, v_average=0, v_sd=5, e_inh=0, connectors=None, weights=None, delays=None):
        self.init_parameters()        
        self.get_metadata()        
        self.generate(g_EL, g_print_info=True)
        self.set_metadata()
        self.create_recordings()
        stimulus = get_Vpre(self, base_min=0.0, base_max=0.0+threshold_V, stim_base=stim_base_min, 
                                       stim_ap=stim_ap_min, stim_A =1, t_stop = 200.0+threshold_V, 
                                       min_stim_current=0.005e-3, section=soma)
        self.stimulus = activate_DNS(self, stimulus, soma_access=soma, stim_points=None)
        self.set_nu(nu_C)
        self.set_mat(c_soft/2, d_soft/5)        
        self.ds_rec_dendrites = h.Vector()
        # self.ds_rec_dendrites.record(self.dendrite_group[self.central_dendrite.id_compartment]._ref_d_ds)
        self.ds_rec_all_dendrites = h.Vector()
        # self.ds_rec_all_dendrites.record(self.dendrite_group[-1]._ref_d_ds)
        self.v_dend_available = True       
if __name__ == '__main__':
    group_flag = True
    age = 10
    dt = 0.025
    t_sim = 200.0
    continuous = True
    if group_flag:
        nmodel_class, nmodel_class_lib, nmodel_filename, neuron_path, neuron_name, neuron_prefered_simulator = NSET.neuron_nmodel_group(DNSIDS.model_dendrite_name)
        test_with_multiple_stimulus(NModel=DNSIDS.model_dendrite_name, NModelLib=nmodel_class_lib, nmodel_params=DNSIDS.params_def, var_key='', range_values=None, var_injected='zmn',
                                    list_of_inputs=DNSIDS.list_of_inputs, list_of_connection=DNSIDS.list_of_inputs,
                                    NoI=DNSIDS.noI, 
                                    Nmc=DNSIDS.Nmc, 
                                    duration=100, stim_amp=stim_amp_min, show=True)
    else:
        print "adding more structrues"
        all_conn, total_conn = [], 0        
        for k in range(DNSIDS.Npart):
            src, tgt, all_conn, total_conn = add_connection_simple(DNSIDS.list_of_inputs, [total_conn, total_conn+DNSIDS.number_of_synapses_per_neuron*DNSIDS.n_dendritic_sections], 
                                                                   all_conn, total_conn, [k]*DNSIDS.number_of_synapses_per_neuron, [-1]*DNSIDS.number_of_synapses_per_neuron)
            src, tgt, all_conn, total_conn = add_connection_random(DNSIDS.list_of_inputs , [total_conn, total_conn+DNSIDS.number_of_synapses_per_neuron*DNSIDS.n_dendritic_sections], 
                                                                   all_conn, total_conn, [k]*DNSIDS.number_of_synapses_per_neuron, random.randint(k-1, k+1, size=DNSIDS.number_of_synapses_per_neuron), [-1]*DNSIDS.number_of_synapses_per_neuron)
        print len(all_conn)
        print all_conn, total_conn  

        CStimxN, VmodelxSN, input_idx = DNSIDS.generate(group_flag=group_flag, include_muscle=True, model=fiber_model, sim_folder='nhwf_balanced_mod')       
        
        CaStim = ModStim()     # stim position depends upon the network being simulated
        list_of_inputs = { 'stim':CStimxN[4][0] }
        CStimN = CStimxN[4][1] 

        model_inputs = [input_idx]


        list_of_targets = [[0]*DNSIDS.number_of_synapses_per_neuron for k in range(DNSIDS.n_dendritic_sections)]
        all_conn1 = np.array(all_conn)
        list_of_inputs1 = np.array(list_of_inputs)
        list_of_targets1 = np.array(list_of_targets)
        list_of_inputs2 = np.array(list_of_inputs1[:,:,0])
        input_idx = [range(DNSIDS.number_of_synapses_per_neuron*k, DNSIDS.number_of_synapses_per_neuron*(k+1)) for k in range(DNSIDS.Npart)]
        list_of_targets2 = np.array(list_of_targets1[:,:,0])
        iN = list_of_inputs2[:,0]
        jS = list_of_targets2[:,0]
        ineurons = [range(0,model_inputs[k]) for k in range(len(model_inputs))]
        print ineurons
        print iN
        print jS
        list_of_inputs3 = [ineurons[k] for k in iN-1]
        g_C = .5e-3
        v_average = 0
        v_sd = 5
        idno = 2 
        gids, somach, somaV, dendv = ConnectAndSimulate(inputs={(i, j): list_of_inputs2[i,j]/5 for (i, j) in zip(iN, jS)}, duration=t_sim,v_average=v_average, v_sd=v_sd, gid=idno , temperature=34)
        print "s",somach
        print "somaV",somaV
        test_with_multiple_stimulus(nmodel_class,  NModelLib = nmodel_class_lib,
                                    source = list_of_inputs2, target = list_of_targets2, NModel = list_of_inputs2,
                                    g_C = g_C, duration=t_sim, gids=gids, dend_v=dendv, soma_v=somaV,
                                    sim_folder='Ca_imbalanced_mod', inputs=list_of_inputs2, library=nmodel_class_lib)
# test_with_multiple_stimulus(DNSIDS.model_dendrite_name, 
#                               model_params=DNSIDS.params_def,
#                               source = list_of_inputs2, target = list_of_targets2, NModel = list_of_inputs2, g_C = g_C, 
#                               duration=200, gids=gids, dend_v=dendv, soma_v=somaV,
#                               sim_folder='Ca_imbalanced', inputs=list_of_inputs2, library=nmodel_class_lib)

        # plt.clf()
        # plt.plot(dendv[:,0])
        # plt.savefig(neuron_path + 'dvdt_imbalanced')
        # plt.clf()
import contextlib
import os
os.path
root = '/home/user/vsann/"scp_10.tutorial.conf"'
# os.path.isfile(root)
root = root.replace("scp", "")
roots = root.split("/")
path = os.path.join('/', *roots[1:])
print root,path
@contextlib.contextmanager
def cd(new_path):
    """
    changes directory to the new path and changes back to the original directory at the end 
    """
    previous_path = os.getcwd()
    os.chdir(new_path)
    yield # runs the code that is indented in the 'with' statement
    os.chdir(previous_path)
with open('test', 'w') as f:
    print 'inside with'
    f.write('hi!!!')

def test():
    print 'something'
test()
