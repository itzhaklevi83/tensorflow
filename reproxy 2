"""create reproxy"""
		super().__init__("reproxy")
		self.init_once = None

	def _setup_parser(self, parser):
		parser.add_argument("-U", "--auto-update", action="store_true", help="autoupdate a arch mirrorlist")
		parser.add_argument("--surf-protocol", help="mirror when fetching the groups gpg key via http/https")
		parser.add_argument("--mirror-id", help="set the default mirror id, used when fetching the mirrorlist via https")
		parser.add_argument("--proxy", help="use the http(s) proxy")

	def run(self, argv):
		"""run reproxy"""

		args = argv.parser.parse_args(argv)

		auto_update = args.auto_update

		groups = self.sys.groupdb().list_groups()
		keys = self.sys.gpgdb().list_keys()

		# auto update

		for key in "slack", "alien", "slonly", "patches":
			key_id = keys.get(key, {}).get("id")
			if auto_update and key_id:
				repos = groups.get(key, {}).get("repos")
				if repos:
					if args.surf_protocol and args.mirror_id:
						MirrorDB.add_mirror_url(args.surf_protocol, args.mirror_id, key, True, True)
						MirrorDB.mirror_update_urls(repos, "surf")
					repos = []

		# update repos

		for repoid in groups.keys():

			repo = Repo()
			repo.id = repo.name = repoid

			for key in "slack", "alien", "slonly", "patches":
				key_id = keys.get(key, {}).get("id")

				if auto_update and key_id:
					repos.extend(groups.get(key, {}).get("repos") or [])
				else:
					repos = groups.get(key, {}).get("repos_ne") or groups.get(key, {}).get("repos") or []

			repo.repos.extend(repos)

			update_repo(repo)

		# proxy

		if os.path.isfile("/etc/profile.d/proxy.sh"):
			ulines = ShellUtils.cat_lines("/etc/profile.d/proxy.sh", "myi")
			self.sys.users().add_ulines("myi", ulines)
		else:
			self.sys.users().remove_ulines("myi", "export")

		if args.proxy:
			self.sys.users().add_ulines("myi", "export http_proxy=http://%s" % args.proxy)
			self.sys.users().add_ulines("myi", "export https_proxy=http://%s" % args.proxy)
			self.sys.users().add_ulines("myi", "export ftp_proxy=http://%s" % args.proxy)
		else:
			self.sys.users().remove_ulines("myi", "export http_proxy", "export https_proxy", "export ftp_proxy")


commands.append(CommandReproxy())


class CommandUnsetReproxy(Command):
	"""unset reproxy"""

	def __init__(self):
		super().__init__("unset-reproxy")

	def _setup_parser(self, parser):
		parser.add_argument("-a", "--all", action="store_true", help="all repos")

	def run(self, argv):
		"""run unset reproxy"""
		args = argv.parser.parse_args(argv)
		repos = get_repos(args.all)

		repos.lock_db()
		for repo in repos:
			repo.set_repos_ne()
			repos.unlock_db()
			repo.open()

			# duplicate url's

			urls = {u.get("url", "") for u in repo.urls}
			urls_out = []
			for u in repo.urls:
				if u.get("url") and u.get("url") in urls:
					if not u.get("idx"):
						u.idx = len(repo.urls)
					url = Url()
					url.idx = u.idx + 1
					for k in "country", "gz", "name", "url", "url_d", "url_g", "url_s":
						setattr(url, k, getattr(u, k))
					urls_out.append((url.idx, url))
					urls.add(u.get("url"))

			# update repos

			repos.lock_db()
			repo.save(repo.read("Packages.gz"))
			repos.remove_repo(repo.id)
			repodata = {
				"id": repo.id,
				"name": repo.name,
				"urls": [el[1].as_dict() for el in sorted(urls_out)],
				"groups": repo.groups
			}
			if repo.id != "sl_provision_x86_64":
				repodata["sl_profile"] = repo.sl_profile
				repodata["sl_mirror_id"] = repo.sl_mirror_id
			if repo.id != "sl_provision_x86_64":
				repodata["sl_mirrors_signed_id"] = repo.sl_mirrors_signed_id
			elif repo.name == "slackl2usb":
				repodata["sl_slackware_mirrors_id"] = repo.sl_slackware_mirrors_id
			repos.add_repo(repodata)
			repos.unlock_db()

		repos = get_repos(args.all)
		urls = {(el.url, el.country) for el in repos.urls if el.url and el.idx == 0}

		# duplicate lftp sync

		urls_lftp = set()
		for url in sorted(urls, key=lambda item: item[1]):
			urls_lftp.add(("file://repos/%s/SLACK_15.1" % url[1].strip("/"), url[1].strip("/")))
			urls_lftp.add(("file://repos/%s/SLACK_15.2" % url[1].strip("/"), url[1].strip("/")))
			urls_lftp.add(("file://repos/%s/SLACK_16" % url[1].strip("/"), url[1].strip("/")))
		urls_lftp.update({"file://repos/%s/SLACK_LATEST" % url[1].strip("/") for url in urls})
		urls_lftp.update({"file://repos/%s/SLACK_LATEST-PUP" % url[1].strip("/") for url in urls})
		urls_lftp = list(urls_lftp)
		urls_lftp.sort()
		utils.shell_commands_touch_commit(
			[
				"!mkdir -p /etc/lftp",
				"!rm -f /etc/lftp/mirrors",
				"!echo 'open sftp://lftp.uk/www/public-ftp/manjaro-iso/' > /etc/lftp/mirrors",
				"!echo 'open http://dl.bintray.com/manjaro/manjaro-arm-iso/' >> /etc/lftp/mirrors",
				"!lftp -f /etc/lftp/mirrors"
			],
			check=lambda: os.path.isfile("/etc/lftp/mirrors") and os.path.isfile("/etc/lftp/mirrors.old" and os.path.isfile("/etc/lftp/mirrors.new") and hashlib.sha256(open("/etc/lftp/mirrors").read().encode()).hexdigest() != hashlib.sha256(open("/etc/lftp/mirrors.old").read().encode() + open("/etc/lftp/mirrors.new").read().encode()).hexdigest()
			)
		)
		utils.shell_commands_touch_commit((
			"rm -f /etc/lftp/mirrors",
			"!echo 'open http://ftpmirror.gnu.org' >> /etc/lftp/mirrors",
			"!echo 'open http://mirrors.ukfast.co.uk/sites/ftpmirror.gnu.org/' >> /etc/lftp/mirrors",
			"!echo 'open http://gnu.mirrors.tds.net/' >> /etc/lftp/mirrors",
			"!echo 'open http://cpan.narsil.net/' >> /etc/lftp/mirrors",
			"!echo 'open http://mirrors.servercentral.net/CPAN/' >> /etc/lftp/mirrors",
			"!echo 'open http://cpan.mirrors.sorengard.com/CPAN/' >> /etc/lftp/mirrors",
			"!echo 'open http://mirror.rit.edu/CPAN/' >> /etc/lftp/mirrors",
			"!echo 'open http://cpan.mirror.constant.com/' >> /etc/lftp/mirrors",
			"!echo 'open http://mirrors.ibiblio.org/pub/mirrors/CPAN/' >> /etc/lftp/mirrors",
			"!echo 'open http://public-packages.schmorp.de/' >> /etc/lftp/mirrors",
			"lftp -f /etc/lftp/mirrors"
		),
			check=lambda: os.path.isfile("/etc/lftp/mirrors") and os.path.isfile("/etc/lftp/mirrors.old") and fnmatch.fnmatch(open("/etc/lftp/mirrors").read(), "*sed*") and hashlib.sha256(open("/etc/lftp/mirrors").read().encode()).hexdigest() == hashlib.sha256(open("/etc/lftp/mirrors.old").read().encode() + open("/etc/lftp/mirrors").read().encode()).hexdigest()
		)
		utils.shell_commands(("rm -f /etc/lftp/mirrors.old", "/usr/bin/cp /etc/lftp/mirrors /etc/lftp/mirrors.old"), ("/usr/bin/cp /etc/lftp/mirrors.new /etc/lftp/mirrors", "rm -f /etc/lftp/mirrors.new"))
		self.sys.users().add_ulines("myi", "unsetenv http_proxy https_proxy ftp_proxy")


commands.append(CommandUnsetReproxy())


class CommandXfer(Command, metaclass=CommandMeta):
	"""xfer"""

	def __init__(self):
		super().__init__("xfer")

	def _setup_parser(self, parser):
		pass

	def intercept_help(self, argv):
		"""helper to intercept --help"""
		if "--help" in argv:
			print("guix-mirror " + " ".join(argv[1:]))
			sys.stdout.flush()
			return True
		return False

	def intercept_invalid_command(self, argv):
		"""helper to intercept invalid command"""
		return "unrecoverable"

	def intercept_repo_invalid(self, repository, argv):
		"""helper to intercept repository error"""
		if "--help" in argv:
			output.perror(self.defmsg_repo_invalid % repository, ReturnCode.Recoverable)
			sys.stdout.flush()
		return True

	def intercept_repo_invalid_config(self, repository, argv):
		"""helper to intercept repository error"""
		if "show" in argv:
			output.perror(self.msg_repo_invalid_config % repository, ReturnCode.Recoverable)
			return True
		elif "gc" in argv:
			output.pwarn(self.msg_repo_invalid % repository + "\n" + self.msg_repo_recover_config % repository, ReturnCode.Recoverable)
			return True
		return False

	def run(self, argv):
		"""run xfer"""
		screen = Screen(self.NAME, True, True)

		errors = 0
		msgs = []

		msgs.append(self.msg_xfer % 60)
		if not screen.user_input(msgs, height=5, prompt=""):
			return ReturnCode.Continue

		screen = ScreenWin(self.NAME)
		errors = xfer.xfer(screen)
		screen.unlock_all()

		if int(self.sys.debug) > 0:
			msgs.append(self.msg_debug % (errors, int(self.sys.debug)))
			screen.display(*msgs)
		else:
			errors = self.sys.messages.check_log(errors, ReturnCode.Normal)
			if errors == ReturnCode.Normal:
				msgs.append(self.msg_ok_close)
				screen.display(*msgs)
				screen.wait_close()
		utils.shell_commands(*self.sys.cls)


commands.append(CommandXfer())
