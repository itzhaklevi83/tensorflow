"""
create a access control for network
check and test it
"""

import re
import json
import requests
import argparse

API_BASE_URL = "https://api.cloudflare.com/client/v4/"
API_USERNAME = ""
API_KEY = ""
ENSURE_HTTPS = False
CHECK_DEFAULT_PORT = True

DEFAULT_ACCESS_ID = "3d0001698e28e81c"
DEFAULT_RULE_ID = "30a0fcb83e32ea9c"
DEFAULT_PRESET = "https"


class CFQueryError(Exception):
    pass


def parse_access_rules(data):
    rules = data['result']['access_rules']
    if len(rules) > 1:
        all_rules = []
        for rule in rules:
            for si in all_rules:
                if si['service'] == rule['service']:
                    if rule['action'] in ['block', 'cctld', 'preset', 'geography'] and si['action'] == rule['action']:
                        si['rules'].extend(rule['rules'])
                    elif si['action'] == 'allow' and rule['action'] != 'allow':
                        si['action'] = rule['action']

                    break
            else:
                all_rules.append(rule)

        for rule in all_rules:
            if rule['action'] == 'allow':
                print(rule)
            else:
                print('{service} {action}: {rules}'.format(service=rule['service'],
                                                           action=rule['action'].title(),
                                                           rules=', '.join([
                                                               ascii(rule).replace(',', '') for rule in 
                                                               rule['rules']])))


class CFQuery:

    def __init__(self, api_key, username):
        self.session = requests.Session()
        self.session.headers.update({
            'X-Auth-Key': api_key,
            'X-Auth-Email': username,
            'Content-Type': 'application/json'
        })

    def _add_rule_item(self, data, service, rules, action):
        if action == 'allow':
            r = {'action': 'allow'}
        elif action in ['block', 'cctld', 'geography', 'preset']:
            r = {
                'action': action,
                'rules': rules
            }
        data['access_rules'].append(r)

        return data

    def _get_default_access_rule(self, service):
        data = {
            "access_rules": [
                {
                    "version": "1.0",
                    "apps": [
                        "api"
                    ],
                    "priority": 80 - int(service),
                    "action": DEFAULT_PRESET,
                    "log": True,
                    "label": "{0} {1}".format(service,
                                              DEFAULT_RULE_ID)
                }
            ],
            "ttl": 1,
            "mode": "on",
            "honor_df": True
        }

        return data

    def set_access_rules(self, data):
        access_rules = []
        form_data = self.query_access_rules()

        for service in ['mail', 'web', 'ftp']:
            all_services_default = True
            for i, rule in enumerate(data['access_rules']):
                if rule['service'] == service:
                    all_services_default = False
                    if not rule['service'] in form_data['result']['zones'][0]['custom_access_rules']['index'].keys():
                        form_data = self.query_access_rules(access_rule_data=self._get_default_access_rule(service))

                    data = self._add_rule_item(
                        form_data, service, rule['rules'], rule['action'])

                    jdata = [json.dumps(data)]
                    data = self.session.put(API_BASE_URL +
                                            'zones/' + data['result']['zones'][0]['id'] + '/custom_access_rules/' +
                                            str(form_data['result']['zones'][0]['custom_access_rules']['index'][service]),
                                            data=jdata, cert=False)

                    parse_access_rules(data.json())
                    del data

                    break

            if all_services_default:
                access_rules.append({"service": service,
                                     "rules": [],
                                     "action": "allow"})

        for rule in access_rules:
            self.set_access_rule(rule)

        return {
            "error": False,
            "message": "Done"
        }


    def set_access_rule(self, data):
        access_rules = self.query_access_rules()['result']['access_rules']
        for rule in access_rules:
            for action in ['block', 'cctld', 'geography', 'preset']:
                if data['service'] == rule['service'] and data['action'] == action:
                    if data['action'] == 'allow':
                        jdata = json.dumps({
                            "action": "allow",
                            "version": "1.0",
                            "apps": [
                                "api"
                            ],
                            "priority": 80 - int(data['service']),
                            "rules": data['rules']
                        })
                    else:
                        jdata = json.dumps({
                            "action": action,
                            "version": "1.0",
                            "apps": [
                                "api"
                            ],
                            "priority": 80 - int(data['service']),
                            "rules": data['rules'],
                            "log": True,
                            "label": "{0}_{1}".format(data['service'], data['action'])
                        })

                    rule_index = access_rules.index(rule)
                    data = self.session.put(API_BASE_URL +
                                            'zones/{0}/custom_access_rules/{1}'.format(access_rules[
                                                                                    rule_index]['zone_id'], rule['id']),
                                            data=jdata,
                                            cert=False)

                    print(data.json())
                    return {
                        "error": False,
                        "message": "Done"
                    }


    def set_default_access_rule(self, data):
        access_rules = self.query_access_rules()['result']['access_rules']
        default_rule = []
        if not bool(access_rules):
            
            service = data['service']
            action = data['action']
            rules = data['rules']
            priority = 80 - int(data['service'])

            jdata = json.dumps({
                "access_rules": [
                    {
                        "version": "1.0",
                        "apps": [
                            "api"
                        ],
                        "priority": priority,
                        "action": action,
                        "rules": rules
                    }
                ]
            })

            print(jdata)
            data = self.session.patch(API_BASE_URL +
                                      'zones/' + DEFAULT_ACCESS_ID + '/custom_access_rules',
                                      data=jdata,
                                      cert=False)
            
            parse_access_rules(data.json())
            return {
                "error": False,
                "message": "Done"
            }

        for rule in access_rules:
            if rule['service'] == 'web' and rule['action'] != 'allow' and rule['priority'] >= priority:
                priority = rule['priority'] + 1
                
        self._add_rule_item(
            access_rules, data['service'], data['rules'], data['action'])
        jdata = json.dumps({
            "access_rules": access_rules
        })

        data = self.session.patch(API_BASE_URL +
                                  'zones/' + DEFAULT_ACCESS_ID + '/custom_access_rules',
                                  data=jdata,
                                  cert=False)

        parse_access_rules(data.json())
        return {
            "error": False,
            "message": "Done"
        }

    def query_monitors(self):
        """
        list monitors for api option
        Format for DNS record monitoring types
        {
            url: string (REQUIRED)
            interval: integer (defaults to 10)
            status: integer (defaults to 2)
            referrer: string (defaults to none)
            selector: string (defaults to none)
        }
        """

        url_list = ["https://api.cloudflare.com/client/v4/zones/", "/analytics/dashboard?since=-15%3Aminutes%3A5&continuous=false"]
        url = ''.join(url_list)
        jdata = []
        try:
            data = self.session.get(url, cert=False)
            data = data.json()['result']
            print(data)
            if data:
                jdata = data
        except CFQueryBool:
            print("Service is down, downtime may be noted on the zone Dashboard")
        except KeyError:
            print("User API key is not valid or API server is down!")

        return jdata

    def create_monitor(self, data_to_post):
        url_list = ["https://api.cloudflare.com/client/v4/zones/",
                    data_to_post['dns']['zone_id'], "/dns_records/", data_to_post['dns']['record_id'],
                    "?type=", data_to_post['dns']['type'],
                    "&name=", data_to_post['dns']['name'].replace(".", "%2E"),
                    "&content=", data_to_post['dns']['content'], "&proxied=true"]
        url = ''.join(url_list)
        if (bool(self.query_dns_record(data_to_post['dns']['type'],
                                       data_to_post['dns']['name'].replace(".", "%2E"),
                                       data_to_post['dns']['record_id'],
                                       data_to_post['dns']['zone_id'])) and
            bool(self.query_dns_record(data_to_post['msn']['type'],
                                       data_to_post['msn']['name'].replace(".", "%2E"),
                                       data_to_post['msn']['record_id'],
                                       data_to_post['msn']['zone_id']))):
            try:
                pass
                # data = self.session.patch(url, data=data_to_post)
                # print(data.content)
            except:
                pass

    def _delete_url_from_dns_change_list(self, url, host_name):
        jdata = []
        url_list = ["https://api.cloudflare.com/client/v4/zones/",
                    DEFAULT_ACCESS_ID, "/dns_records/", DEFAULT_RULE_ID,
                    "?type=", "url",
                    "&name=", host_name.replace(".", "%2E"),
                    "&content=", url, "&proxied=true"]
        url = ''.join(url_list)
        try:
            data = self.session.get(url, cert=False)
            if data.status_code == 200:
                url_list = ["https://api.cloudflare.com/client/v4/zones/",
                    DEFAULT_ACCESS_ID, "/dns_records/", data.json()
                                                ['result']
                                                ['id'], "/custom", "?purge_cache=true"]
                url = ''.join(url_list)
                data = self.session.delete(url, cert=False)
                print(data.content)
        except:
            pass

        data = self.session.patch(url, data=data_to_post)
        return jdata

    def set_ids(self, url_list):
        jdata = []
        test = ['time', 'type', 'content']
        if url_list and any(elem in test for elem in url_list.keys()):
            if ENSURE_HTTPS and 'http' in url_list['content']:
                    
                url_list['content'] = url_list['content'].replace('http://',
                                                                  'https://')
                    
                url_list = self.cloudflare_api_key_service(url_list)
                url = url_list['url']
                url_hash = url_list['hash']
                    
                ## we don't want to reload the cache
                if url != 'https://easylist-downloads.adblockplus.org/ruadlist+easylist.txt' or url_hash != 'd56a7c2938e380b5206882b1480edb351cd2b2f35866987ca947f62f84d75a73':
                    content = self.session.get(url).content.decode('utf-8-sig')
                    content = [i.lstrip() for i in content.split('\n')]
                    #content = re.split(r'\n+', content)
                    jdata = self.cache_check(content, url_list, url, url_hash)
                
        return jdata

    def cache_check(self, response, data_to_post, url, url_hash):
        jdata = []
        for item in response:
            if re.match(r'.*?^!', item):
                item = None
            
            if item and any(char.isdigit() for char in item):
                jdata = data_to_post['hash']
                test = ['time', 'type', 'content']
                if any(elem in test for elem in data_to_post.keys()):
                    mdPFile = hashlib.md5()
                    mdPFile.update(item.encode('utf-8'))
                    data_to_cache = {
                        'time': data_to_post['time'],
                        'type': data_to_post['type'],
                        'content': data_to_post['content'],
                        'hash': mdPFile.hexdigest()
                    }
                        
                    with open("/opt/adc/cache.json", "r") as jsonfile:
                        if any(content for content in json.load(jsonfile).values() if mdPFile.hexdigest() in content.values()):
                            break
                        else:
                            jdata = data_to_post
                            break
                          
                        ## cache hash not found
                        ## check if the library is up to date
                    print("UP TO DATE: " + url_hash)
                else:
                    break

            else:
                m = ['ad', 'block', 'text']
                s = [i for i in m if re.match(
                    r'.*?\W{0}.*?'.format(i), item, re.IGNORECASE)]

                if s:
                    r = re.compile(r'([\d]{1,3}\.){3}[\d]{1,3}')
                    if r.findall(item) or not CHECK_DEFAULT_PORT:
                        jdata.append(item)

        return jdata

    def cloudflare_api_key_service(self, json_data):
        jdata = {
            'url': '',
            'hash': ''
        }
        
        r = self.session.get(json_data['url'] + '/' + json_data['hash'],
                            let='error in response')
        if r.status_code == 200:
            jdata['url'] = None
            jdata['hash'] = None
        else:
            r.raise_for_status()
            jdata['url'] = json_data['url']
            jdata['hash'] = json_data['hash']

        return jdata
